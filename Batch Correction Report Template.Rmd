---
title: "Batch Correction Reporting Template"
author: "Erick Helmeczi"
date: "2024-08-08"
output: html_document
runtime: shiny
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r, include = FALSE}
# Load packages

library("tidyverse")
library("stats")
library("rmarkdown")
library("factoextra") # For PCA
library("pmp") # for QCRSC batch correction
```

```{r}
# Read and prepare data

data <- read.csv("study matrix.csv")
data$class <- as.factor(data$class)
data$batch <- as.factor(data$batch)

```

```{r}
# Reactive functions

## Perform user selected transformation to all metabolites

transformed_data <- reactive({
  
  temp_df <- data
  
  if (input$transformer == "Log10") {
    temp_df[, 5:ncol(data)] <- log(data[, 5:ncol(data)], base = 10)
  } else if (input$transformer == "ln") {
    temp_df[, 5:ncol(data)] <- log(data[, 5:ncol(data)])
  } else if (input$transformer == "Cube Root") {
    temp_df[, 5:ncol(data)] <- (data[, 5:ncol(data)])^(1/3)
  }
  
  return(temp_df)
  
})
  
## Autoscale data

autoscaled_data <- reactive({
  
  temp_df <- transformed_data()
  
  if(input$autoscaler == TRUE){
    temp_df[, 5:ncol(temp_df)] <- scale(temp_df[, 5:ncol(temp_df)], center = TRUE, scale = TRUE)
  }else{
    temp_df
  }
  
  return(temp_df)
  
})

```


This R Markdown document provides the following summaries and features:

  1. A brief overview of the distribution of sample and pooled quality control data. Normalization tools are provided to prepare data for future statistical analyses. Control chart for individual metabolites based on run order to identify batch effects and signal drift.
  2. Several batch correction algorithms are provided along with cross validation results.
  3. An export function is available for the final transformed and batch corrected data set.
  
<hr style="border:1px solid black">

<div align = "center">

## Section 1: Data Summary Before Batch Correction

<div align = "left">

<hr style="border:1px solid black">

### Distribution Transformation

The data transformers available below will be applied throughout the entire report if selected. 

```{r}
inputPanel(
  
  selectInput(
  inputId = "transformer",
  label = "Data Transformer",
  choices = c("None", "Log10", "ln", "Cube Root"),
  selected = "None",
  multiple = FALSE,
  selectize = TRUE,
  width = NULL,
  size = NULL)
  
)

```

### Metabolite Distribution Overview

This section explores the distribution of the raw data prior to any batch correction. 

```{r}
inputPanel(
  
  varSelectInput(
  inputId = "metabolite",
  label = "Metabolite Selection:",
  data = data[, 5:ncol(data)],
  selected = NULL,
  multiple = FALSE,
  selectize = TRUE,
  width = NULL,
  size = NULL),

selectInput(
  inputId = "class_filter", 
  label = "Class Selection:", 
  choices = c("Both", "QC", "Sample"), 
  selected = "Sample"),

numericInput(
  inputId = "bins",
  label = "Number of Bins:",
  value = 15,
  min = 0,
  max = NA,
  step = 1,
  width = NULL),

)

# Histogram

output$histogramPlot <- renderPlot({
  
  # filter data
  
  plot_data <- transformed_data()
  
  plot_data <-   if (input$class_filter != "Both") {
    subset(plot_data, plot_data$class == input$class_filter)
  } else {
    plot_data
  }
  
  # plot
  
  ggplot(data = plot_data, aes(x = .data[[input$metabolite]])) +
    geom_histogram(bins = input$bins, color = "white", alpha = 0.7, aes(fill = batch)) +
    theme_classic() +
    theme(text = element_text(size = 25),
          axis.text = element_text(color="black"),
          axis.ticks = element_line(color = "black")) +
    scale_x_continuous(breaks = scales::breaks_pretty(), name = paste(input$metabolite, "Response", sep = " ")) +
    scale_y_continuous(breaks = scales::breaks_pretty(), name = "Count") +
    ggtitle(paste(input$metabolite, "Histogram", sep = " "))
})

# Quantile-quantile plot

output$qqPlot <- renderPlot({
  
    # filter data
  
  plot_data <- transformed_data()
  
  plot_data <-   if (input$class_filter != "Both") {
    subset(plot_data, plot_data$class == input$class_filter)
  } else {
    plot_data
  }
  
  ggplot(data = plot_data, aes(sample = .data[[input$metabolite]])) +
    stat_qq() +
    stat_qq_line() +
    theme_classic() + 
    theme(text = element_text(size = 25),
          axis.text = element_text(color="black"),
          axis.ticks = element_line(color = "black")) +
    scale_x_continuous(breaks = scales::breaks_pretty(), name = "Normal Theoretical Quantiles") +
    scale_y_continuous(breaks = scales::breaks_pretty(), paste(input$metabolite, "Response", sep = " ")) +
    ggtitle(paste(input$metabolite, "Q-Q Plot", sep = " "))
})

# Metabolite Histograms and Q-Q Plots

renderUI({
  fluidRow(
    column(6, plotOutput("histogramPlot")),
    column(6, plotOutput("qqPlot"))
  )
})


```

---

### Table Summary

The table below summarizes key statistics for each metabolite. The columns "Mean" and "Standard_Deviation" were calculated with sample data (QC data is omitted). Biological and technical precisions have units of percent. The intraclass correlation coefficient (ICC) was calculated with the following equation:

$$
\Large ICC = \frac{\sigma^2_{\text{Biological}}} {\sigma^2_{\text{Biological}} + \sigma^2_{\text{Technical}}}
$$


```{r}

# initialize reactive elements

table_summary_values <- reactiveValues(
  bio_cv_median = NULL,
  bio_cv_range = NULL,
  tech_cv_median = NULL,
  tech_cv_range = NULL
)

renderDataTable({
  
  # prepare data
  
  data <- transformed_data()
  
  sample_df <- data[which(data$class == "Sample"), 5:ncol(data)]
  qc_df <- data[which(data$class == "QC"), 5:ncol(data)]
  
  # calculate cvs
  
  biological_cv <- apply(sample_df, 2, sd) / colMeans(sample_df) * 100
  technical_cv <- apply(qc_df, 2, sd) / colMeans(qc_df) * 100
  
  # calculate reactive outputs for markdown text
  
  table_summary_values$bio_cv_median <- round(median(biological_cv), 2)
  table_summary_values$bio_cv_range <- paste(round(min(biological_cv), 2), "-", round(max(biological_cv), 2), sep = " ")
  table_summary_values$tech_cv_median <- round(median(technical_cv), 2)
  table_summary_values$tech_cv_range <- paste(round(min(technical_cv), 2), "-", round(max(technical_cv), 2), sep = " ")
  
  # generate table summary

  table_summary <- data.frame("Metabolite" = colnames(sample_df),
                            "Mean" = colMeans(sample_df),
                            "Standard_Deviation" = apply(sample_df, 2, sd),
                            "Biological_CV" = biological_cv,
                            "Technical_CV" = technical_cv,
                            "ICC" = (apply(sample_df, 2, sd))^2 / ((apply(sample_df, 2, sd))^2 + (apply(qc_df, 2, sd))^2))

  table_summary[,2:ncol(table_summary)] <- round(table_summary[,2:ncol(table_summary)], digits = 2)
  
  return(table_summary)
  
})

```

```{r}

renderText({
  paste("In summary, the median technical CV is ", table_summary_values$tech_cv_median,  "% with a range of ", table_summary_values$tech_cv_range, "%. The median biological CV is ",table_summary_values$bio_cv_median,  "% with a range of ", table_summary_values$bio_cv_range, "%", sep = "")
})

```

---

### PCA Comparing Technical and Biological Variation of Uncorrected Data

```{r}

inputPanel(
  
  checkboxInput(inputId = "autoscaler", 
                label = "Autoscale Data", 
                value = TRUE, 
                width = NULL),
  
)

renderPlot({
  
  # convert class to numeric for prcomp function

  pca_data <- autoscaled_data()
  pca_data$class <- ifelse(pca_data$class == "Sample", 1, 0)
  
  pca_results <- prcomp(pca_data[, c(2,5:ncol(pca_data))], 
                 center = FALSE,
                 scale = FALSE)
 
 scree.plot <- fviz_eig(pca_results)

pc1 <- scree.plot[["data"]][["eig"]][1] %>%
  round(., 1)
pc2 <- scree.plot[["data"]][["eig"]][2] %>%
  round(., 1)
  
  fviz_pca_ind(pca_results,
             col.ind = data$class,
             palette = c("#FF5733", "#1ABC9C"),
             addEllipses = TRUE, 
             legend.title = "Groups",
             label = "none",
             repel = FALSE,
             mean.point = FALSE,
             pointsize = 3,
             pointshape = 19,
             alpha = 0.5) +
  theme(text = element_text(size = 20, family = "sans"),
        plot.title = element_blank(),
        axis.text = element_text(colour="black", face = "plain", size = 20, family = "sans"),
        axis.line = element_line(linewidth = 0.5, colour = "black", linetype = 1)) +
  scale_y_continuous(name = paste("PC 2 (", pc2, "%)", sep = ""),
                     breaks = scales::pretty_breaks(n = 10)) +
  scale_x_continuous(name = paste("PC 1 (", pc1, "%)", sep = ""),
                     breaks = scales::pretty_breaks(n = 10)) 
  
  
})


```

---

### Metabolite Control Charts

The control charts below should be used to help identify inter- and intra- batch effects which may be correctable in the following section. Red hashed lines represent 95% confidence intervals while the black solid line represents the mean of the data.

```{r qc, echo=FALSE}
inputPanel(
  
  varSelectInput(
  inputId = "cc_metabolite",
  label = "Metabolite Selection:",
  data = data[, 5:ncol(data)],
  selected = NULL,
  multiple = FALSE,
  selectize = TRUE,
  width = NULL,
  size = NULL
),

selectInput(
  inputId = "cc_class_filter", 
  label = "Class Selection:", 
  choices = c("Both", "QC", "Sample"), 
  selected = "Sample"),

sliderInput(inputId = "point_size", 
            label = "Point Size:",
            min = 1, 
            max = 10,
            value = 5)

)

# plot control chart

renderPlot({
  
  # prepare data
  
  plot_data <- transformed_data()
  
  plot_data <- if (input$cc_class_filter != "Both") {
    subset(plot_data, plot_data$class == input$cc_class_filter)
  } else {
    plot_data <- transformed_data()
  }
  
  # Calculate metrics for control chart aesthetics
  
  mean_value <- mean(plot_data[[input$cc_metabolite]])
  upper_limit <- mean(plot_data[[input$cc_metabolite]]) + 1.96 * sd(plot_data[[input$cc_metabolite]])
  lower_limit <- mean(plot_data[[input$cc_metabolite]]) - 1.96 * sd(plot_data[[input$cc_metabolite]])
  
  ggplot(data = plot_data, aes(x = run_order, y = .data[[input$cc_metabolite]], color = batch)) +
    geom_point(size = input$point_size) +
    geom_hline(yintercept = mean_value, linetype = "solid", color = "black", size = 0.5) +
    geom_hline(yintercept = upper_limit, linetype = "dashed", color = "red", size = 0.5) +
    geom_hline(yintercept = lower_limit, linetype = "dashed", color = "red", size = 0.5) +
    theme_classic() +
    theme(text = element_text(size = 25),
          axis.text = element_text(color="black"),
          axis.ticks = element_line(color = "black")) +
    scale_x_continuous(breaks = scales::breaks_pretty(), name = "Run Order") +
    scale_y_continuous(breaks = scales::breaks_pretty(), name = "Response") +
    labs(color = "Batch") +
    ggtitle(paste(input$cc_metabolite, "Control Chart", sep = " "))
  
})
```

<hr style="border:1px solid black">

<div align = "center">

## Section 2: Batch Correction

</div>

<div align = "left">

<hr style="border:1px solid black">

```{r}

qcrsc_corrected <- reactive({
  
  df <- transformed_data()
  
  results_temp <- QCRSC(df = df[, 5:ncol(df)],
                            order = df$run_order,
                            batch = df$batch,
                            classes = df$class,
                            spar = 0,
                            log = FALSE,
                            minQC = 4,
                            qc_label = "QC")
  
  results_temp <- t(results_temp)
  
  df[, 5:ncol(df)] <- results_temp
  
  return(df)
  
})

```

```{r}
inputPanel(
  
  varSelectInput(
  inputId = "cc_metabolite",
  label = "Metabolite Selection:",
  data = data[, 5:ncol(data)],
  selected = NULL,
  multiple = FALSE,
  selectize = TRUE,
  width = NULL,
  size = NULL
),

selectInput(
  inputId = "cc_class_filter", 
  label = "Class Selection:", 
  choices = c("Both", "QC", "Sample"), 
  selected = "Sample"),

sliderInput(inputId = "point_size", 
            label = "Point Size:",
            min = 1, 
            max = 10,
            value = 5)

)

# plot control chart

renderPlot({
  
  # prepare data
  
  plot_data <- qcrsc_corrected()
  
  plot_data <- if (input$cc_class_filter != "Both") {
    subset(plot_data, plot_data$class == input$cc_class_filter)
  } else {
    plot_data <- transformed_data()
  }
  
  # Calculate metrics for control chart aesthetics
  
  mean_value <- mean(plot_data[[input$cc_metabolite]])
  upper_limit <- mean(plot_data[[input$cc_metabolite]]) + 1.96 * sd(plot_data[[input$cc_metabolite]])
  lower_limit <- mean(plot_data[[input$cc_metabolite]]) - 1.96 * sd(plot_data[[input$cc_metabolite]])
  
  ggplot(data = plot_data, aes(x = run_order, y = .data[[input$cc_metabolite]], color = batch)) +
    geom_point(size = input$point_size) +
    geom_hline(yintercept = mean_value, linetype = "solid", color = "black", size = 0.5) +
    geom_hline(yintercept = upper_limit, linetype = "dashed", color = "red", size = 0.5) +
    geom_hline(yintercept = lower_limit, linetype = "dashed", color = "red", size = 0.5) +
    theme_classic() +
    theme(text = element_text(size = 25),
          axis.text = element_text(color="black"),
          axis.ticks = element_line(color = "black")) +
    scale_x_continuous(breaks = scales::breaks_pretty(), name = "Run Order") +
    scale_y_continuous(breaks = scales::breaks_pretty(), name = "Response") +
    labs(color = "Batch") +
    ggtitle(paste(input$cc_metabolite, "Control Chart", sep = " "))
  
})
```


